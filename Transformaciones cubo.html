<!DOCTYPE html>
<html>
    <head>
        <title>Titulo</title>
        <style>
            html, body { margin: 0; padding: 0; overflow: hidden; }
            #text {
                position: absolute;
                padding: 10px;
                width: 100%;
                text-align: center;
                color: #FFFFFF;
            }
        </style>
    </head>
    <body>
        <div id="text">Computacion Grafica<br/>
            Cubo<br/>
            Transformaciones<br/>
            David Paez<br/>
        </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r94/three.min.js"></script>
    <script>


    
    function cubo(posini,lado, material){ 
        GeoCuadrado=new THREE.Geometry(); //Guarda los vertices de un cubo
        var vertices = [[posini[0]-lado/2,posini[1]-lado/2,posini[2]-lado/2], //6
                        [posini[0]-lado/2,posini[1]+lado/2,posini[2]-lado/2], //5
                        [posini[0]+lado/2,posini[1]+lado/2,posini[2]-lado/2], //8
                        [posini[0]+lado/2,posini[1]-lado/2,posini[2]-lado/2], //7
                        [posini[0]-lado/2,posini[1]-lado/2,posini[2]-lado/2], //6 
                        [posini[0]-lado/2,posini[1]-lado/2,posini[2]+lado/2], //3
                        [posini[0]-lado/2,posini[1]+lado/2,posini[2]+lado/2], //4           Se hace el reccorido de vertice a vertice por medio de un array
                        [posini[0]+lado/2,posini[1]+lado/2,posini[2]+lado/2], //1         se enumero cada uno de los vertices del cubo del 1 al 8 para recorrerlo
                        [posini[0]+lado/2,posini[1]-lado/2,posini[2]+lado/2], //2
                        [posini[0]-lado/2,posini[1]-lado/2,posini[2]+lado/2], //3 
                        [posini[0]-lado/2,posini[1]-lado/2,posini[2]-lado/2], //6
                        [posini[0]+lado/2,posini[1]-lado/2,posini[2]-lado/2], //7
                        [posini[0]+lado/2,posini[1]-lado/2,posini[2]+lado/2], //2 
                        [posini[0]+lado/2,posini[1]+lado/2,posini[2]+lado/2], //1
                        [posini[0]+lado/2,posini[1]+lado/2,posini[2]-lado/2], //8 
                        [posini[0]-lado/2,posini[1]+lado/2,posini[2]-lado/2], //5
                        [posini[0]-lado/2,posini[1]+lado/2,posini[2]+lado/2], //4 
                        ];
        var largoVertice = vertices.length;
        for (i = 0; i < largoVertice; i++) {
            x = vertices[i][0];
            y = vertices[i][1];
            z = vertices[i][2];
            vector = new THREE.Vector3(x, y, z);
            GeoCuadrado.vertices.push(vector); 
        }
        this.getlado=function(){ 
            return lado
        }
        micubito=new THREE.Line(GeoCuadrado,material);
        return micubito;
     }
    
    function Escalado(factor,cubo){ //funcion de escalado
        var matrizS = new THREE.Matrix4(); 
        matrizS.set(factor[0], 0, 0, 0,
                    0, factor[1], 0, 0,
                    0, 0, factor[2], 0,
                    0, 0, 0, 1);

                    cubo.applyMatrix(matrizS);
                    scene.add(cubo); 
    }
    function Translacionx(lado,cubo){ //Funcion de traslacion
        var matrizT = new THREE.Matrix4(); 
        matrizT.set(1, 0, 0, 2*lado,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1);

                cubo.applyMatrix(matrizT);
                scene.add(cubo); 
    }
    function Rotacionx(angle,cubo){ //Funcion de Rotacion en el eje x

        var matrizRx = new THREE.Matrix4();
        var alpha = angle;
        var cs = Math.cos(alpha);
        var ss = Math.sin(alpha);

        matrizRx.set(1,  0, 0, 0, 
                    0,  cs, -ss, 0, 
                    0, ss, cs, 0,
                    0, 0, 0, 1);

        cubo.applyMatrix( matrizRx); 
        scene.add(cubo);
}
function Rotaciony(angle,cubo){ //Funcion de Rotacion en el eje y

var matrizRy = new THREE.Matrix4();
var alpha = angle;
var cs = Math.cos(alpha);
var ss = Math.sin(alpha);

matrizRy.set(cs,  0, ss, 0, 
            0, 1, 0, 0,
            -ss,0,cs,0,
            0, 0, 0, 1);

cubo.applyMatrix( matrizRy); 
scene.add(cubo);
}
function Rotacionz(angle,cubo){ //Funcion de Rotacion en el eje z

var matrizRz = new THREE.Matrix4();
var alpha = angle;
var cs = Math.cos(alpha);
var ss = Math.sin(alpha);

matrizRz.set(cs, -ss, 0, 0, //rotacion en x 
            ss,  cs, 0, 0, 
            0, 0, 1, 0,
            0, 0, 0, 1);

cubo.applyMatrix( matrizRz); 
scene.add(cubo);
}
        


    function init() {  

       
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);    
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);

        var size = 700;
        var arrowSize = 40;
        var divisions = 20; 
        var origin = new THREE.Vector3( 0, 0, 0 );
        var x = new THREE.Vector3( 1, 0, 0 );
        var y = new THREE.Vector3( 0, 1, 0 );
        var z = new THREE.Vector3( 0, 0, 1 );
        var color2 = new THREE.Color( 0x333333 );  
        var colorR = new THREE.Color( 0xAA0000 ); 
        var colorG = new THREE.Color( 0x00AA00 );
        var colorB = new THREE.Color( 0x0000AA );

        //Crear la Rejilla 
        var gridHelperXZ = new THREE.GridHelper( size, divisions, color2, color2); 

        //Flechas
        var arrowX = new THREE.ArrowHelper( x, origin, arrowSize, colorR );                                    
        var arrowY = new THREE.ArrowHelper( y, origin, arrowSize, colorG );
        var arrowZ = new THREE.ArrowHelper( z, origin, arrowSize, colorB );  
			
        //Camara
        camera.position.x = 100;
        camera.position.y =80;
        camera.position.z = 400;
        camera.lookAt(scene.position); // enfoque a la posicion de la escena 
        //Materiales
        Material1=new THREE.ParticleBasicMaterial({color:0xffffff});//blanco
        Material2=new THREE.ParticleBasicMaterial({color:0x0000ff});//azul
        //Creacion de Cubitos 
       var Cubo1= cubo([0,0,0],60,Material1);
       var Cubo2traslacion = cubo([0,0,0],60,Material2);
       var Cubo3escalado= cubo([0,0,0],60,Material1);
       var Cubo4rotacionx= cubo([0,0,0],60,Material2);
       //Transformaciones
       Translacionx(getlado(),Cubo2traslacion);
       //se usa el getter inicializado anteriormente para realizar la traslacion
       Escalado([1.5,1.5,1.5],Cubo3escalado); 
       //se escala el cubo al 150%
       Rotacionx(45,Cubo4rotacionx);
       //se hace la rotacion al cubo en un angulo de 45 grados
       
        document.body.appendChild(renderer.domElement); 

        // se anaden a la escena los 4 cubos con sus respectivas tranformaciones
        scene.add(Cubo1); 
        scene.add(gridHelperXZ);
	    scene.add(arrowX);	
		scene.add(arrowY);	
		scene.add(arrowZ);
        
    

        renderer.render(scene, camera);
    }

    init();  

    </script>
  </body>
</html>